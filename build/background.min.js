(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
console.log("Inside Background Page")

// TODO Look into whether context menus would work

var browserExtension = new (require("./lib/chrome-extension"))({
  chromeTabs: chrome.tabs,
  chromeBrowserAction: chrome.browserAction,
  extensionURL: function (path) {
    return chrome.extension.getURL(path);
  },
  isAllowedFileSchemeAccess: function (fn) {
    return chrome.extension.isAllowedFileSchemeAccess(fn);
  },
});

browserExtension.listen(window);

// TODO Look into onInstalled and onUpdated.


},{"./lib/chrome-extension":3}],2:[function(require,module,exports){
'use strict';

// Cache the tab state constants.
var states = require("./tab-state").states;

// Each button state has two icons one for normal resolution (19) and one
// for hi-res screens (38).
var icons = {};
icons[states.ACTIVE] = {
  19: 'images/icon19.png',
  38: 'images/icon19@2x.png'
};
icons[states.INACTIVE] = {
  19: 'images/icon19.png',
  38: 'images/icon19@2x.png'
};

// Fake localization function.
function _(str) {
  return str;
}

/* Controls the display of the browser action button setting the icon, title
 * and badges depending on the current state of the tab. This is a stateless
 * module and does not store the current state. A TabState instance should
 * be used to manage which tabs are active/inactive.
 */
function BrowserAction(chromeBrowserAction) {
  this.setState = function (tabId, state) {
    switch (state) {
      case states.ACTIVE:   this.activate(tabId); break;
      case states.INACTIVE: this.deactivate(tabId); break;
      case states.ERRORED:  this.error(tabId); break;
      default: throw new TypeError('State ' + state + ' is invalid');
    }
  };

  /* Sets the active browser action appearance for the provided tab id. */
  this.activate = function (tabId) {
    chromeBrowserAction.setIcon({tabId: tabId, path: icons[states.ACTIVE]});
    chromeBrowserAction.setTitle({tabId: tabId, title: _('Hypothesis is active')});
  };

  /* Sets the inactive browser action appearance for the provided tab id. */
  this.deactivate = function (tabId) {
    chromeBrowserAction.setIcon({tabId: tabId, path: icons[states.INACTIVE]});
    chromeBrowserAction.setTitle({tabId: tabId, title: _('Hypothesis is inactive')});
  };

  /* Sets the errored browser action appearance for the provided tab id. */
  this.error = function (tabId) {
    chromeBrowserAction.setIcon({tabId: tabId, path: icons[states.INACTIVE]});
    chromeBrowserAction.setTitle({tabId: tabId, title: _('Hypothesis has failed to load')});
    chromeBrowserAction.setBadgeText({tabId: tabId, text: '!'});
  };
}

BrowserAction.icons = icons;

module.exports = exports = BrowserAction;


},{"./tab-state":7}],3:[function(require,module,exports){
'use strict';

console.log("Inside chrome extension")

var TAB_STATUS_COMPLETE = 'complete';

/* The main extension application. This wires together all the smaller
 * modules. The app listens to all new created/updated/removed tab events
 * and uses the TabState object to keep track of whether the sidebar is
 * active or inactive in the tab. The app also listens to click events on
 * the browser action and toggles the state and uses the BrowserAction module
 * to update the visual style of the button.
 *
 * The SidebarInjector handles the insertion of the Hypothesis code. If it
 * runs into errors the tab is put into an errored state and when the
 * browser aciton is clicked again the HelpPage module displays more
 * information to the user.
 *
 * Lastly the TabStore listens to changes to the TabState module and persists
 * the current settings to localStorage. This is then loaded into the
 * application on startup.
 *
 * Relevant Chrome Extension documentation:
 * - https://developer.chrome.com/extensions/browserAction
 * - https://developer.chrome.com/extensions/tabs
 * - https://developer.chrome.com/extensions/extension
 *
 * dependencies - An object to set up the application.
 *   chromeTabs: An instance of chrome.tabs.
 *   chromeBrowserAction: An instance of chrome.browserAction.
 *   extensionURL: chrome.extension.getURL.
 *   isAllowedFileSchemeAccess: chrome.extension.isAllowedFileSchemeAccess.
 */
function ChromeExtension(dependencies) {
  var chromeTabs = dependencies.chromeTabs;
  var chromeBrowserAction = dependencies.chromeBrowserAction;
  var help  = new (require("./help-page"))(chromeTabs, dependencies.extensionURL)
  var store = new (require("./tab-store"))(localStorage)
  var state = new (require("./tab-state"))(store.all(), onTabStateChange)
  var browserAction = new (require("./browser-action"))(chromeBrowserAction)
  var sidebar = new (require("./sidebar-injector"))(chromeTabs, {
    extensionURL: dependencies.extensionURL,
    isAllowedFileSchemeAccess: dependencies.isAllowedFileSchemeAccess,
  })
  var tabErrors = new (require("./tab-error-cache"))()

  /* Sets up the extension and binds event listeners. Requires a window
   * object to be passed so that it can listen for localStorage events.
   */
  this.listen = function (window) {
    chromeBrowserAction.onClicked.addListener(onBrowserActionClicked);
    chromeTabs.onCreated.addListener(onTabCreated);
    // chromeTabs.onUpdated.addListener(onTabUpdated);
    chromeTabs.onRemoved.addListener(onTabRemoved);

    // FIXME: Find out why we used to reload the data on every get.
    window.addEventListener('storage', function (event) {
      var key = 'state';
      var isState = event.key === key;
      var isUpdate = event.newValue !== null;

      // Check the event is for the store and check that something has
      // actually changed externally by validating the new value.
      if (isState && isUpdate && event.newValue !== JSON.stringify(store.all())) {
        store.reload();
        state.load(store.all());
      }
    });
  };

  /* A method that can be used to setup the extension on existing tabs
   * when the extension is installed.
   */
  this.install = function () {
    chromeTabs.query({}, function (tabs) {
      tabs.forEach(function (tab) {
        if (state.isTabActive(tab.id)) {
          state.activateTab(tab.id, {force: true});
        } else {
          state.deactivateTab(tab.id, {force: true});
        }
      });
    });
  };

  /* Opens the onboarding page */
  // this.firstRun = function () {
  //   chromeTabs.create({url: 'https://hypothes.is/welcome'}, function (tab) {
  //     state.activateTab(tab.id);
  //   });
  // };

  function onTabStateChange(tabId, current, previous) {
    if (current) {
      browserAction.setState(tabId, current);

      if (!state.isTabErrored(tabId)) {
        store.set(tabId, current);
        tabErrors.unsetTabError(tabId);
        chromeTabs.get(tabId, updateTabDocument);
      }
    } else {
      store.unset(tabId);
      tabErrors.unsetTabError(tabId);
    }
  }

  function onBrowserActionClicked(tab) {

    var tabError = tabErrors.getTabError(tab.id);
    if (state.isTabErrored(tab.id) && tabError) {
      help.showHelpForError(tab, tabError);
    }
    else if (state.isTabActive(tab.id)) {
      state.deactivateTab(tab.id);
    }
    else {
      state.activateTab(tab.id);
    }
  }

  function onTabUpdated(tabId, changeInfo, tab) {
    // This function will be called multiple times as the tab reloads.
    // https://developer.chrome.com/extensions/tabs#event-onUpdated
    if (changeInfo.status !== TAB_STATUS_COMPLETE) {
      return;
    }

    if (state.isTabErrored(tabId)) {
      state.restorePreviousState(tabId);
    }

    if (state.isTabActive(tabId)) {
      browserAction.activate(tabId);
    } else {
      browserAction.deactivate(tabId);
    }

    return updateTabDocument(tab);
  }

  function onTabCreated(tab) {
    state.deactivateTab(tab.id);
  }

  function onTabRemoved(tabId) {
    state.clearTab(tabId);
  }

  function updateTabDocument(tab) {
    // If the tab has not yet finished loading then just quietly return.
    if (tab.status !== TAB_STATUS_COMPLETE) {
      return Promise.resolve();
    }

    if (state.isTabActive(tab.id)) {
      return sidebar.injectIntoTab(tab).catch(function (err) {
        tabErrors.setTabError(tab.id, err);
        state.errorTab(tab.id);
      });
    }
    else if (state.isTabInactive(tab.id)) {
      return sidebar.removeFromTab(tab);
    }
  }
}

module.exports = exports = ChromeExtension


},{"./browser-action":2,"./help-page":4,"./sidebar-injector":5,"./tab-error-cache":6,"./tab-state":7,"./tab-store":8}],4:[function(require,module,exports){
'use strict';

var err = require("./help-page")

/* A controller for displaying help pages. These are bound to extension
 * specific errors (found in errors.js) but can also be triggered manually.
 *
 * chromeTabs   - An instance of chrome.tabs.
 * extensionURL - A function that recieves a path and returns a full path
 *   to the file inside the chrome extension. See:
 *   https://developer.chrome.com/extensions/extension#method-getURL
 */
function HelpPage(chromeTabs, extensionURL) {
  /* Accepts an instance of h.ExtensionError and displays an appropriate
   * help page if one exists.
   *
   * tab   - The tab to display the error message in.
   * error - An instance of h.ExtensionError.
   *
   * Throws an error if no page is available for the action.
   * Returns nothing.
   */
  this.showHelpForError = function (tab, error) {
    if (error instanceof err.LocalFileError) {
      return this.showLocalFileHelpPage(tab);
    }
    else if (error instanceof err.NoFileAccessError) {
      return this.showNoFileAccessHelpPage(tab);
    }
    else if (error instanceof err.RestrictedProtocolError) {
      return this.showRestrictedProtocolPage(tab);
    }

    throw new Error('showHelpForError does not support the error: ' + error.message);
  };

  this.showLocalFileHelpPage = showHelpPage.bind(null, 'local-file');
  this.showNoFileAccessHelpPage = showHelpPage.bind(null, 'no-file-access');
  this.showRestrictedProtocolPage = showHelpPage.bind(null, 'restricted-protocol');

  // Render the help page. The helpSection should correspond to the id of a
  // section within the help page.
  function showHelpPage(helpSection, tab) {
    chromeTabs.create({
      index: tab.index + 1,
      url:  extensionURL('/help/index.html#' + helpSection),
      openerTabId: tab.id,
    });
  }
}

module.exports = exports = HelpPage;

},{"./help-page":4}],5:[function(require,module,exports){
'use strict';

var err = require("./help-page")
var urlChecks = require("./url-checks")

/* The SidebarInjector is used to deploy and remove the Hypothesis sidebar
 * from tabs. It also deals with loading PDF documents into the PDF.js viewer
 * when applicable.
 *
 * chromeTabs - An instance of chrome.tabs.
 * dependencies - An object with additional helper methods.
 *   isAllowedFileSchemeAccess: A function that returns true if the user
 *   can access resources over the file:// protocol. See:
 *   https://developer.chrome.com/extensions/extension#method-isAllowedFileSchemeAccess
 *   extensionURL: A function that receives a path and returns an absolute
 *   url. See: https://developer.chrome.com/extensions/extension#method-getURL
 */
function SidebarInjector(chromeTabs, dependencies) {
  dependencies = dependencies || {};

  var isAllowedFileSchemeAccess = dependencies.isAllowedFileSchemeAccess;
  var extensionURL = dependencies.extensionURL;

  if (typeof extensionURL !== 'function') {
    throw new TypeError('extensionURL must be a function');
  }

  if (typeof isAllowedFileSchemeAccess !== 'function') {
    throw new TypeError('isAllowedFileSchemeAccess must be a function');
  }

  /* Injects the Hypothesis sidebar into the tab provided.
   *
   * tab - A tab object representing the tab to insert the sidebar into.
   *
   * Returns a promise that will be resolved if the injection succeeded
   * otherwise it will be rejected with an error.
   */
  this.injectIntoTab = function (tab) {
    console.log("injectIntoTab: ", tab.url)
    if (urlChecks.isFileURL(tab.url)) {
      return injectIntoLocalDocument(tab);
    } else {
      return injectIntoRemoteDocument(tab);
    }
  };

  /* Removes the Hypothesis sidebar from the tab provided.
   *
   * tab - A tab object representing the tab to remove the sidebar from.
   *
   * Returns a promise that will be resolved if the removal succeeded
   * otherwise it will be rejected with an error.
   */
  this.removeFromTab = function (tab) {
    if (urlChecks.isPDFViewerURL(tab.url)) {
      return removeFromPDF(tab);
    } else {
      return removeFromHTML(tab);
    }
  };

  function injectIntoLocalDocument(tab) {
    if (urlChecks.isPDFURL(tab.url)) {
      return injectIntoLocalPDF(tab);
    } else {
      return Promise.reject(new err.LocalFileError('Local non-PDF files are not supported'));
    }
  }

  function injectIntoRemoteDocument(tab) {
    return urlChecks.isPDFURL(tab.url) ? injectIntoPDF(tab) : injectIntoHTML(tab);
  }

  function injectIntoPDF(tab) {
    return new Promise(function (resolve, reject) {
      if (!urlChecks.isPDFViewerURL(tab.url)) {
        chromeTabs.update(tab.id, {url: urlChecks.getPDFViewerURL(tab.url)}, function () {
        	console.log("injectIntoPDF and notViewerURL")
        	sendMessageToEmbedBeagle()
          resolve();
        });
      } else {
      	console.log("injectIntoPDF")
      	sendMessageToEmbedBeagle()
        resolve();
      }
    });
  }

  function injectIntoLocalPDF(tab) {
    return new Promise(function (resolve, reject) {
      isAllowedFileSchemeAccess(function (isAllowed) {
        if (isAllowed) {
          resolve(injectIntoPDF(tab));
        } else {
          reject(new err.NoFileAccessError('Local file scheme access denied'));
        }
      });
    });
  }

  function injectIntoHTML(tab) {
    return new Promise(function (resolve, reject) {
      if (!urlChecks.isSupportedURL(tab.url)) {
        var protocol = tab.url.split(':')[0];
        return reject(new err.RestrictedProtocolError('Cannot load Hypothesis into ' + protocol + ' pages'));
      }

      return (function (isInjected) {
        if (!isInjected) {
        	console.log('Normally, inject public/config here.')
          // injectConfig(tab.id).then(function () {
            chromeTabs.executeScript(tab.id, {
              code: 'window.annotator = true'
            }, function () {
              console.log('Normally, execute public/embed.js here.')
              sendMessageToEmbedBeagle()
              // chromeTabs.executeScript(tab.id, {
              //   file: 'public/embed.js'
              // }, resolve);
            });
          // });
        } else {
        	sendMessageToEmbedBeagle()
          resolve();
        }
      })()
    });
  }

  function removeFromPDF(tab) {
    return new Promise(function (resolve) {
      var url = tab.url.slice(urlChecks.getPDFViewerURL('').length).split('#')[0];
      chromeTabs.update(tab.id, {
        url: decodeURIComponent(url)
      }, resolve);
    });
  }

  function removeFromHTML(tab) {
    return new Promise(function (resolve, reject) {
      if (!urlChecks.isSupportedURL(tab.url)) {
        return resolve();
      }

      // TODO Implement removal

      return isSidebarInjected(tab.id).then(function (isInjected) {
        // var src  = extensionURL('/public/destroy.js');
        // var code = 'var script = document.createElement("script");' +
        //   'script.src = "{}";' +
        //   'document.body.appendChild(script);' +
        //   'delete window.annotator;';

        // if (isInjected) {
        // chromeTabs.executeScript(tab.id, {
        //   // code: code.replace('{}', src)
        // }, resolve);
    		// resolve()
        // } else {
          resolve();
        // }
      });
    });
  }

  function isSidebarInjected(tabId) {
    return new Promise(function (resolve, reject) {
      return chromeTabs.executeScript(tabId, {code: 'window.annotator'}, function (result) {
        var isAnnotatorSet = !!(result && result[0]);
        resolve(isAnnotatorSet);
      });
    });
  }

  function sendMessageToEmbedBeagle () {
  	chromeTabs.getSelected(null, function(tab) {
      chromeTabs.sendMessage(
        //Selected tab id
        tab.id,
        //Params inside a object data
        {
          callFunction: "toggleSidebar",
          modules: [  'altmetrics' ]
        },
        // Optional callback function
        function(response) {
	        console.log("Chrome tabs message 'toggleSidebar' sent.")
        }
      )
    })
  }

  // function injectConfig(tabId) {
  //   return new Promise(function (resolve) {
  //     var src  = extensionURL('/public/config.js');
  //     var code = 'var script = document.createElement("script");' +
  //       'script.src = "{}";' +
  //       'document.body.appendChild(script);';
  //     chromeTabs.executeScript(tabId, {code: code.replace('{}', src)}, resolve);
  //   });
  // }
}

module.exports = exports = SidebarInjector


},{"./help-page":4,"./url-checks":9}],6:[function(require,module,exports){
'use strict';

/* A wrapper around an Object for storing and retrieving error objects
 * created when trying to inject the Sidebar into the document. This
 * primarily exists to simplify the testing of the error handling. As
 * the setters/getters can easily be stubbed.
 */
function TabErrorCache() {
  var cache = {};

  this.getTabError = function (tabId, err) {
    return cache[tabId] || null;
  };

  this.setTabError = function (tabId, err) {
    cache[tabId] = err;
  };

  this.unsetTabError = function (tabId) {
    delete cache[tabId];
  };
}

module.exports = exports = TabErrorCache;

},{}],7:[function(require,module,exports){
var states = {
  ACTIVE:   'active',
  INACTIVE: 'inactive',
  ERRORED:  'errored',
};

/* Manages the state of the browser action button to ensure that it displays
 * correctly for the currently active tab. An onchange callback will be
 * called when the extension changes state. This will be provided
 * with the tabId, the current and previous states.
 *
 * Each state has a method to enable it such as activateTab() and a method
 * to query the current state such as isTabActive().
 *
 * initialState - An Object of tabId/state keys. Used when loading state
 *   from a persisted store such as localStorage.
 * onchange     - A function that recieves onchange(tabId, current, prev).
 */
function TabState(initialState, onchange) {
  var _this = this;
  var currentState;
  var previousState;

  this.onchange = onchange || null;

  /* Replaces the entire state of the object with a new one.
   *
   * newState - An object of tabId/state pairs.
   *
   * Returns nothing.
   */
  this.load = function (newState) {
    previousState = currentState || {};
    currentState = newState;
  };

  this.activateTab = function (tabId, options) {
    transition(tabId, states.ACTIVE, options);
  };

  this.deactivateTab = function (tabId, options) {
    transition(tabId, states.INACTIVE, options);
  };

  this.errorTab = function (tabId, options) {
    transition(tabId, states.ERRORED, options);
  };

  this.clearTab = function (tabId) {
    transition(tabId, null);
  };

  this.restorePreviousState = function (tabId) {
    transition(tabId, previousState[tabId], this.onchange);
  };

  this.isTabActive = function (tabId) {
    return currentState[tabId] === states.ACTIVE;
  };

  this.isTabInactive = function (tabId) {
    return currentState[tabId] === states.INACTIVE;
  };

  this.isTabErrored = function (tabId) {
    return currentState[tabId] === states.ERRORED;
  };

  // options.force allows the caller to re-trigger an onchange event for
  // the current state without modifying the previous state. This is useful
  // for restoring tab state after the extension is reloaded.
  function transition (tabId, state, options) {
    var isForced = !!options && options.force === true;
    var hasChanged = state !== currentState[tabId];
    if (!isForced && !hasChanged) { return; }

    if (!isForced || hasChanged) {
      previousState[tabId] = currentState[tabId];
      currentState[tabId] = state;
    }

    if (typeof _this.onchange === 'function') {
      _this.onchange(tabId, state, previousState[tabId] || null);
    }
  }

  this.load(initialState || {});
}

TabState.states = states;

module.exports = exports = TabState;



},{}],8:[function(require,module,exports){
'use strict()';

/* The tab store ensures that the current state of the browser action
 * is persisted between browser sessions. To do this it uses an external
 * storage object that conforms to the localStorage API.
 *
 * Examples
 *
 *   var store = new TabStore(window.localStorage);
 */
function TabStore(storage) {
  var key = 'state';
  var local;

  this.get = function (tabId) {
    var value = local[tabId];
    if (!value) {
      throw new Error('TabStateStore could not find entry for tab: ' + tabId);
    }
    return value;
  };

  this.set = function (tabId, value) {
    local[tabId] = value;
    storage.setItem(key, JSON.stringify(local));
  };

  this.unset = function (tabId) {
    delete local[tabId];
    storage.setItem(key, JSON.stringify(local));
  };

  this.all = function () {
    return local;
  };

  this.reload = function () {
    try {
      local = JSON.parse(storage.getItem(key));
    } catch (e) {
      local = null;
    }
    local = local || {};
  };

  this.reload();
}

module.exports = exports = TabStore


},{}],9:[function(require,module,exports){
var extensionURL = function (path) {
  return chrome.extension.getURL(path);
}

var getPDFViewerURL = function(url) {
	var PDF_VIEWER_URL = extensionURL('/content/web/viewer.html');
	return PDF_VIEWER_URL + '?file=' + encodeURIComponent(url);
}

var isPDFURL = function(url) {
	return url.toLowerCase().indexOf('.pdf') > 0;
}

var isPDFViewerURL = function(url) {
	return url.indexOf(getPDFViewerURL('')) === 0;
}

var isFileURL = function(url) {
	return url.indexOf("file:") === 0;
}

var isSupportedURL = function(url) {
	var SUPPORTED_PROTOCOLS = ['http:', 'https:', 'ftp:'];
	return SUPPORTED_PROTOCOLS.some(function (protocol) {
		return url.indexOf(protocol) === 0;
	});
}

module.exports.getPDFViewerURL = exports.getPDFViewerURL = getPDFViewerURL
module.exports.isPDFURL = exports.isPDFURL = isPDFURL
module.exports.isPDFViewerURL = exports.isPDFViewerURL = isPDFViewerURL
module.exports.isFileURL = exports.isFileURL = isFileURL
module.exports.isSupportedURL = exports.isSupportedURL = isSupportedURL


},{}]},{},[1]);
